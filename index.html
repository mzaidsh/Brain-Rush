<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ¯ Bable Shooter</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const BableShooter = () => {
          const canvasRef = useRef(null);
          const [score, setScore] = useState(0);
          const [gameOver, setGameOver] = useState(false);
          const [audioStarted, setAudioStarted] = useState(false);
          
          const audioContextRef = useRef(null);
          
          const gameState = useRef({
            player: { x: 0, y: 0, size: 50 },
            bullets: [],
            enemies: [],
            lastEnemySpawn: 0,
            score: 0
          });

          const playPuchPuchSound = () => {
            if (!audioContextRef.current) return;
            try {
              const ctx = audioContextRef.current;
              if (ctx.state === 'suspended') {
                ctx.resume();
              }
              const oscillator = ctx.createOscillator();
              const gainNode = ctx.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(ctx.destination);
              
              oscillator.frequency.value = 1000;
              oscillator.type = 'square';
              
              gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
              
              oscillator.start(ctx.currentTime);
              oscillator.stop(ctx.currentTime + 0.05);
            } catch (e) {
              console.error('Puch sound error:', e);
            }
          };
          
          const playPopSound = () => {
            if (!audioContextRef.current) return;
            try {
              const ctx = audioContextRef.current;
              if (ctx.state === 'suspended') {
                ctx.resume();
              }
              const oscillator = ctx.createOscillator();
              const gainNode = ctx.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(ctx.destination);
              
              oscillator.frequency.setValueAtTime(200, ctx.currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.15);
              oscillator.type = 'triangle';
              
              gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
              
              oscillator.start(ctx.currentTime);
              oscillator.stop(ctx.currentTime + 0.15);
            } catch (e) {
              console.error('Pop sound error:', e);
            }
          };
          
          const playBhaggSound = () => {
            if (!audioContextRef.current) return;
            try {
              const ctx = audioContextRef.current;
              if (ctx.state === 'suspended') {
                ctx.resume();
              }
              const oscillator = ctx.createOscillator();
              const gainNode = ctx.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(ctx.destination);
              
              oscillator.frequency.setValueAtTime(400, ctx.currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.4);
              oscillator.type = 'sawtooth';
              
              gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
              
              oscillator.start(ctx.currentTime);
              oscillator.stop(ctx.currentTime + 0.4);
            } catch (e) {
              console.error('Bhagg sound error:', e);
            }
          };

          useEffect(() => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            let animationId;
            
            canvas.width = 800;
            canvas.height = 600;
            
            gameState.current.player.x = canvas.width / 2;
            gameState.current.player.y = canvas.height - 100;
            
            const drawPlayer = () => {
              const p = gameState.current.player;
              ctx.save();
              ctx.translate(p.x, p.y);
              
              ctx.fillStyle = '#FF1493';
              ctx.strokeStyle = '#8B008B';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(-40, 10);
              ctx.lineTo(-25, -5);
              ctx.lineTo(-10, -5);
              ctx.lineTo(5, 10);
              ctx.lineTo(-10, 25);
              ctx.lineTo(-25, 25);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              
              ctx.fillStyle = '#00CED1';
              ctx.strokeStyle = '#006994';
              ctx.beginPath();
              ctx.moveTo(10, -5);
              ctx.lineTo(25, -5);
              ctx.lineTo(40, 10);
              ctx.lineTo(25, 25);
              ctx.lineTo(10, 25);
              ctx.lineTo(-5, 10);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              
              ctx.fillStyle = '#FFD700';
              ctx.strokeStyle = '#FF8C00';
              ctx.beginPath();
              ctx.moveTo(-10, -5);
              ctx.lineTo(10, -5);
              ctx.lineTo(20, 10);
              ctx.lineTo(10, 25);
              ctx.lineTo(-10, 25);
              ctx.lineTo(-20, 10);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              
              ctx.strokeStyle = '#9370DB';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(-17, -5);
              ctx.lineTo(-17, -35);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(-20, -35);
              ctx.lineTo(-20, -45);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(-14, -35);
              ctx.lineTo(-14, -45);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(17, -5);
              ctx.lineTo(17, -35);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(14, -35);
              ctx.lineTo(14, -45);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(20, -35);
              ctx.lineTo(20, -45);
              ctx.stroke();
              
              ctx.fillStyle = '#FF6347';
              ctx.strokeStyle = '#DC143C';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(-15, -55);
              ctx.lineTo(0, -65);
              ctx.lineTo(15, -55);
              ctx.lineTo(15, -45);
              ctx.lineTo(0, -35);
              ctx.lineTo(-15, -45);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              
              ctx.fillStyle = '#32CD32';
              ctx.strokeStyle = '#228B22';
              ctx.beginPath();
              ctx.arc(0, -65, 6, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              
              ctx.restore();
            };
            
            const drawBullet = (bullet) => {
              ctx.save();
              
              ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
              ctx.beginPath();
              ctx.arc(bullet.x, bullet.y, 8, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.fillStyle = '#00FFFF';
              ctx.strokeStyle = '#FF1493';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              
              ctx.restore();
            };
            
            const drawEnemy = (enemy) => {
              ctx.save();
              ctx.translate(enemy.x, enemy.y);
              
              ctx.fillStyle = enemy.color;
              ctx.beginPath();
              ctx.arc(0, 0, 20, 0, Math.PI, true);
              ctx.closePath();
              ctx.fill();
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 3;
              ctx.stroke();
              
              ctx.fillStyle = '#FFFF00';
              ctx.beginPath();
              ctx.arc(0, -20, 8, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = '#FF6600';
              ctx.lineWidth = 2;
              ctx.stroke();
              
              ctx.fillStyle = '#000';
              ctx.beginPath();
              ctx.arc(-8, -8, 3, 0, Math.PI * 2);
              ctx.arc(8, -8, 3, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.restore();
            };
            
            const spawnEnemy = () => {
              const colors = ['#FF00FF', '#00FF00', '#FF8C00', '#9400D3', '#FF1493'];
              gameState.current.enemies.push({
                x: Math.random() * (canvas.width - 40) + 20,
                y: -30,
                speed: 1.5 + Math.random() * 2,
                color: colors[Math.floor(Math.random() * colors.length)]
              });
            };
            
            const gameLoop = (timestamp) => {
              const gs = gameState.current;
              
              const time = timestamp * 0.001;
              const gradient = ctx.createRadialGradient(
                canvas.width / 2 + Math.sin(time) * 100,
                canvas.height / 2 + Math.cos(time) * 100,
                100,
                canvas.width / 2,
                canvas.height / 2,
                canvas.width
              );
              gradient.addColorStop(0, `hsl(${(time * 50) % 360}, 80%, 60%)`);
              gradient.addColorStop(0.5, `hsl(${(time * 50 + 120) % 360}, 80%, 50%)`);
              gradient.addColorStop(1, `hsl(${(time * 50 + 240) % 360}, 80%, 40%)`);
              ctx.fillStyle = gradient;
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
              ctx.lineWidth = 2;
              for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i + (time * 20) % 40, 0);
                ctx.lineTo(i + (time * 20) % 40, canvas.height);
                ctx.stroke();
              }
              for (let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i + (time * 20) % 40);
                ctx.lineTo(canvas.width, i + (time * 20) % 40);
                ctx.stroke();
              }
              
              ctx.fillStyle = 'rgba(255, 0, 255, 0.15)';
              for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(
                  Math.sin(time * 0.5 + i * 0.8) * 300 + canvas.width / 2,
                  Math.cos(time * 0.7 + i * 0.6) * 200 + canvas.height / 2,
                  20 + Math.sin(time + i) * 10,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }
              
              if (timestamp - gs.lastEnemySpawn > 1200) {
                spawnEnemy();
                gs.lastEnemySpawn = timestamp;
              }
              
              gs.bullets = gs.bullets.filter(bullet => {
                bullet.y -= 10;
                if (bullet.y < 0) return false;
                
                let hit = false;
                gs.enemies = gs.enemies.filter(enemy => {
                  const dx = bullet.x - enemy.x;
                  const dy = bullet.y - enemy.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance < 25) {
                    for (let i = 0; i < 3; i++) {
                      ctx.fillStyle = `rgba(255, ${Math.random() * 255}, 0, ${0.6 - i * 0.2})`;
                      ctx.beginPath();
                      ctx.arc(enemy.x, enemy.y, 30 + i * 15, 0, Math.PI * 2);
                      ctx.fill();
                    }
                    
                    gs.score += 10;
                    setScore(gs.score);
                    hit = true;
                    playPopSound();
                    return false;
                  }
                  return true;
                });
                
                if (!hit) drawBullet(bullet);
                return !hit;
              });
              
              gs.enemies = gs.enemies.filter(enemy => {
                enemy.y += enemy.speed;
                
                if (enemy.y > canvas.height) return false;
                
                const dx = enemy.x - gs.player.x;
                const dy = enemy.y - gs.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 50) {
                  setGameOver(true);
                  playBhaggSound();
                  return false;
                }
                
                drawEnemy(enemy);
                return true;
              });
              
              drawPlayer();
              
              ctx.shadowColor = '#FF00FF';
              ctx.shadowBlur = 15;
              ctx.fillStyle = '#00FFFF';
              ctx.strokeStyle = '#FF1493';
              ctx.lineWidth = 4;
              ctx.font = 'bold 32px Arial';
              ctx.strokeText(`SCORE: ${gs.score}`, 20, 45);
              ctx.fillText(`SCORE: ${gs.score}`, 20, 45);
              ctx.shadowBlur = 0;
              
              if (!gameOver) {
                animationId = requestAnimationFrame(gameLoop);
              }
            };
            
            const handleMouseMove = (e) => {
              const rect = canvas.getBoundingClientRect();
              gameState.current.player.x = e.clientX - rect.left;
            };
            
            const shootInterval = setInterval(() => {
              if (!gameOver) {
                gameState.current.bullets.push({
                  x: gameState.current.player.x,
                  y: gameState.current.player.y - 65
                });
                playPuchPuchSound();
              }
            }, 180);
            
            canvas.addEventListener('mousemove', handleMouseMove);
            animationId = requestAnimationFrame(gameLoop);
            
            return () => {
              cancelAnimationFrame(animationId);
              clearInterval(shootInterval);
              canvas.removeEventListener('mousemove', handleMouseMove);
            };
          }, [gameOver]);
          
          const resetGame = () => {
            setGameOver(false);
            setScore(0);
            gameState.current = {
              player: { x: 400, y: 500, size: 50 },
              bullets: [],
              enemies: [],
              lastEnemySpawn: 0,
              score: 0
            };
          };
          
          const startAudio = () => {
            try {
              if (!audioContextRef.current) {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
              }
              audioContextRef.current.resume();
              setAudioStarted(true);
              console.log('Audio Context State:', audioContextRef.current.state);
              
              const testOsc = audioContextRef.current.createOscillator();
              const testGain = audioContextRef.current.createGain();
              testOsc.connect(testGain);
              testGain.connect(audioContextRef.current.destination);
              testOsc.frequency.value = 440;
              testGain.gain.value = 0.1;
              testOsc.start();
              testOsc.stop(audioContextRef.current.currentTime + 0.1);
              console.log('Test sound played!');
            } catch (e) {
              console.error('Audio init error:', e);
            }
          };

          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-900 via-pink-600 to-yellow-500 p-4">
              <div className="bg-gradient-to-r from-cyan-500 to-pink-500 rounded-lg shadow-2xl p-6 border-4 border-yellow-400">
                <h1 className="text-5xl font-bold text-center mb-4 text-white drop-shadow-lg" style={{textShadow: '3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000'}}>
                  ðŸŽ¯ BABLE SHOOTER ðŸŽ¯
                </h1>
                <p className="text-center mb-4 text-white font-bold text-lg drop-shadow-md">
                  Move mouse to vibe! Destroy the cringe! ðŸ”¥ðŸ’¥
                </p>
                
                {!audioStarted && (
                  <div className="text-center mb-4">
                    <button
                      onClick={startAudio}
                      className="bg-gradient-to-r from-green-500 to-blue-600 hover:from-green-600 hover:to-blue-700 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg transform hover:scale-105 transition-transform border-4 border-yellow-400"
                    >
                      ðŸ”Š START WITH SOUND! ðŸ”Š
                    </button>
                  </div>
                )}
                
                <canvas
                  ref={canvasRef}
                  className="border-4 border-purple-600 rounded-lg shadow-2xl cursor-crosshair"
                  style={{ maxWidth: '100%', height: 'auto', boxShadow: '0 0 20px rgba(255,0,255,0.5)' }}
                />
                
                {gameOver && (
                  <div className="mt-6 text-center">
                    <h2 className="text-4xl font-bold text-yellow-300 mb-2 drop-shadow-lg" style={{textShadow: '2px 2px 0 #000'}}>
                      RIP BROTHER! ðŸ’€ðŸ˜­
                    </h2>
                    <p className="text-3xl text-white mb-4 font-bold drop-shadow-md">Score: {score}</p>
                    <button
                      onClick={resetGame}
                      className="bg-gradient-to-r from-pink-500 to-purple-600 hover:from-pink-600 hover:to-purple-700 text-white font-bold py-4 px-10 rounded-full text-2xl shadow-lg transform hover:scale-110 transition-transform border-4 border-yellow-400"
                    >
                      RESPAWN! ðŸš€
                    </button>
                  </div>
                )}
                
                <p className="text-center mt-4 text-white font-bold text-lg drop-shadow-md">
                  No cap, this game slaps fr fr! ðŸŽ®ðŸ’¯
                </p>
              </div>
            </div>
          );
        };

        ReactDOM.render(<BableShooter />, document.getElementById('root'));
    </script>
</body>
</html>
